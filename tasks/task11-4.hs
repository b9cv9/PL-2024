-- результат функции описывается как заданное количество элементов от списка lst
-- если в списке элементов меньше заданного числа, то take выделяет все
f11 x eps n = take (n + 1) lst
  where
    -- который, в свою очередь, начинается с двух заданных значений, а хвост
    -- его хвоста вычисляется как значение функции от этого же списка
    lst = 1.0 : x / 2.0 : elemLst lst 2.0
    xMultX = x * x
    -- функция предполагает, что список бесконечный и в нем можно выделить
    -- два первых элемента по которым можно вычислить очередной
    -- здесь y1 - элемент списка перед тем, который нужно вычислить
    --       y0 - элемент списка перед y1
    elemLst (y0 : ys@(y1 : _)) n =
      if abs (y0 - y1) < eps then [] -- выход по разнице между соседями
        -- иначе вычисляем очередной элемент, он будет головой результата
        -- хвостом результата будет значение функции от хвоста аргумента
      else 2.0 * y1 - xMultX / (n * n) * y0 : elemLst ys (n + 1.0)

--тестовые запуски оформляем в виде функции main без аргументов
main = do -- тело функции - последовательное выполнение
  let res1 = f11 0.5 0.001 500 -- связываем вызов с именем
  putStrLn "f11 0.5 0.001 500"
  print $ res1 !! 10
  print $ res1 !! 100
  print $ res1 !! 500
  
  let res2 = f11 1.0 0.001 500
  putStrLn "f11 1.0 0.001 500"
  print $ res2 !! 10
  print $ res2 !! 100
  print $ res2 !! 500
  
  let res3 = f11 1.7 0.001 500
  putStrLn "f11 1.7 0.001 500"
  print $ res3 !! 10
  print $ res3 !! 100
  print $ res3 !! 500